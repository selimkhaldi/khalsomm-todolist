/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Net = require('net');
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;
const beforeEach = lab.beforeEach;

const Http = require('http');
const Proxyquire = require('proxyquire');
const Os = require('os');

let port = 23888;

let BackEnd;

const beginPort = Math.min(23888, Math.floor(process.pid + 10000 * Math.random() ) & 0xffff);
// free port finder (https://gist.github.com/mikeal/1840641)
const getFreePort = function (cb) {

    let portrange = beginPort;

    const getPort = function (callback) {

        const testedPort = portrange;
        portrange += 1;

        const server = Net.createServer();
        server.listen(testedPort, () => {

            server.once('close', () => {

                callback(testedPort);
            });
            server.close();
        });
        server.on('error', () => {

            getPort(callback);
        });
    };

    return getPort(cb);
};


beforeEach((done) => {

    getFreePort((foundPort) => {

        port = foundPort;
        const Config = { url: 'http://127.0.0.1:' + foundPort };
        BackEnd = Proxyquire('../../../lib/backend', {
            './routes': {
                login: Config.url + '/app-login',
                logout: Config.url + '/app-logout',
                metrics: Config.url + '/metrics',
                beat: Config.url + '/app-beat',
                exception: Config.url + '/sqreen_exception',
                commands: Config.url + '/commands',
                batch: Config.url + '/batch',
                attack: Config.url + '/attack',
                rulespack: Config.url + '/rulespack'
            }
        });
        done();
    });
});


describe('BackEnd', () => {

    describe('login', () => {

        it('should login to a server', { plan: 22 }, (done) => {

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('POST');
                expect(req.url).to.equal('/app-login');
                expect(req.headers.accept).to.equal('application/json');
                expect(req.headers['x-api-key']).to.equal('token');

                let body = '';

                req.on('data', (data) => {

                    body += data;
                });
                req.on('end', () => {

                    const payload = JSON.parse(body);
                    expect(payload).to.includes(['agent_type', 'agent_version', 'os_type', 'hostname', 'runtime_type', 'runtime_version', 'framework_type', 'framework_version', 'environment', 'various_infos']);
                    expect(payload.agent_type).to.equal('nodejs');
                    expect(payload.agent_version).to.equal(require('../../../package.json').version);
                    expect(payload.hostname).to.equal(Os.hostname());
                    expect(payload.os_type).to.includes(Os.arch());
                    expect(payload.os_type).to.includes(Os.type());
                    expect(payload.runtime_type).to.equal('node');
                    expect(payload.runtime_version).to.equal(process.version);

                    expect(payload.framework_type).to.equal('');
                    expect(payload.framework_version).to.not.exist();
                    expect(payload.environment).to.equal('test');
                    expect(payload.various_infos.declared_dependencies).to.equal(require('../../../package.json').dependencies);
                    expect(payload.various_infos.declared_devdependencies).to.equal(require('../../../package.json').devDependencies);

                    expect(payload.various_infos).to.includes(['time', 'dependencies', 'pid', 'euid', 'name']);
                    expect(payload.various_infos.dependencies).to.be.an.array();
                    expect(payload.various_infos.dependencies.length).to.be.above(200);

                    const labPkg = payload.various_infos.dependencies.find((pkg) => pkg.name === 'lab');

                    expect(labPkg).to.exist();

                    res.writeHead(200, { 'content-type': 'application/json' });
                    res.end(JSON.stringify({ status: true, session_id: 'session-key' }) + '\n');
                });
            });

            server.listen(port, () => {

                BackEnd.login('token')
                    .then((token) => {

                        expect(token).to.equal('session-key');
                        server.close(() => {

                            done();
                        });
                    });
            });
        });

        it('should fail to login to a server', { plan: 1, timeout: 60000 }, (done) => {

            const server = Http.createServer((req, res) => {

                res.writeHead(500, { 'content-type': 'application/json' });
                res.end('INTERNAL ERROR\n');
            });

            server.listen(port, () => {

                BackEnd.login('token')
                    .then(() => {

                        server.close(() => {

                            done(new Error('this should have failed'));
                        });
                    })
                    .catch((err) => {

                        expect(err).to.exist();
                        server.close(() => {

                            done();
                        });
                    });
            });
        });

        it('should fail to login to a server because of bad token', { plan: 1, timeout: 60000 }, (done) => {

            const server = Http.createServer((req, res) => {

                res.writeHead(500, { 'content-type': 'application/json' });
                res.end(
                    JSON.stringify(
                        {
                            error: 'Token validation failure',
                            status: false
                        }
                    ) + '\n');
            });

            server.listen(port, () => {

                BackEnd.login('token')
                    .then(() => {

                        server.close(() => {

                            done(new Error('this should have failed'));
                        });
                    })
                    .catch((err) => {

                        expect(err).to.exist();
                        server.close(() => {

                            done();
                        });
                    });
            });
        });

        it('should fail to login to a server', { plan: 1, timeout: 60000 }, (done) => {

            const server = Http.createServer((req, res) => {

                res.writeHead(200, { 'content-type': 'application/json' });
                res.end(JSON.stringify({ status: false }) + '\n');
            });

            server.listen(port, () => {

                BackEnd.login('token')
                    .then(() => {

                        server.close(() => {

                            done(new Error('this sould have failed'));
                        });
                    })
                    .catch((err) => {

                        expect(err).to.exist();
                        server.close(() => {

                            done();
                        });
                    });
            });
        });
    });

    describe('logout', () => {

        it('should logout a user', { plan: 4 }, (done) => {

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('GET');
                expect(req.url).to.equal('/app-logout');
                expect(req.headers['x-session-key']).to.equal('session');

                res.writeHead(200, { 'content-type': 'application/json' });
                res.end(JSON.stringify({ status: true }) + '\n');
            });

            server.listen(port, () => {

                BackEnd.logout('session')
                    .then((response) => {

                        expect(response).to.exist();
                        server.close(() => {

                            done();
                        });
                    })
                    .catch((err) => {

                        server.close(() => {

                            done(err);
                        });
                    });
            });
        });

        it('should fail to logout a user because of error 500', { plan: 5, timeout: 30000 }, (done) => {

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('GET');
                expect(req.url).to.equal('/app-logout');

                res.writeHead(500, { 'content-type': 'application/json' });
                res.end(JSON.stringify({ status: true }) + '\n');
            });

            server.listen(port, () => {

                BackEnd.logout('token')
                    .then(() => {

                        server.close(() => {

                            done(new Error('this should have failed'));
                        });
                    })
                    .catch((err) => {

                        expect(err).to.exist();
                        server.close(() => {

                            done();
                        });
                    });
            });
        });

        it('should fail to logout a user because of false status in payload', { plan: 3, timeout: 30000 }, (done) => {

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('GET');
                expect(req.url).to.equal('/app-logout');

                res.writeHead(200, { 'content-type': 'application/json' });
                res.end(JSON.stringify({ status: false }) + '\n');
            });

            server.listen(port, () => {

                BackEnd.logout('token')
                    .then(() => {

                        server.close(() => {

                            done(new Error('this should have failed'));
                        });
                    })
                    .catch((err) => {

                        expect(err).to.exist();
                        server.close(() => {

                            done();
                        });
                    });
            });
        });

    });

    describe('heartbeat', () => {

        it('should heartbeat', { plan: 4 }, (done) => {

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('GET');
                expect(req.url).to.equal('/app-beat');
                expect(req.headers['x-session-key']).to.equal('session');

                res.writeHead(200, { 'content-type': 'application/json' });
                res.end(JSON.stringify({ status: true, commands: [] }) + '\n');
            });

            server.listen(port, () => {

                BackEnd.heartBeat('session')
                    .then((response) => {

                        expect(response.commands).to.be.an.array();
                        server.close(() => {

                            done();
                        });
                    })
                    .catch((err) => {

                        server.close(() => {

                            done(err);
                        });
                    });
            });
        });

        it('should fail to heartbeat a user because of error 500', { plan: 5, timeout: 30000 }, (done) => {

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('GET');
                expect(req.url).to.equal('/app-beat');

                res.writeHead(500, { 'content-type': 'application/json' });
                res.end(JSON.stringify({ status: true, commands: [] }) + '\n');
            });

            server.listen(port, () => {

                BackEnd.heartBeat('token')
                    .then(() => {

                        server.close(() => {

                            done(new Error('this should have failed'));
                        });
                    })
                    .catch((err) => {

                        expect(err).to.exist();
                        server.close(() => {

                            done();
                        });
                    });
            });
        });

        it('should fail to heartbeat a user because of error 400', { plan: 5, timeout: 30000 }, (done) => {

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('GET');
                expect(req.url).to.equal('/app-beat');

                res.writeHead(400, { 'content-type': 'application/json' });
                res.end(JSON.stringify({ status: true, commands: [] }) + '\n');
            });

            server.listen(port, () => {

                BackEnd.heartBeat('token')
                    .then(() => {

                        server.close(() => {

                            done(new Error('this should have failed'));
                        });
                    })
                    .catch((err) => {

                        expect(err).to.exist();
                        server.close(() => {

                            done();
                        });
                    });
            });
        });

        it('should fail to heartbeat a user because of false status in payload', { plan: 3 }, (done) => {

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('GET');
                expect(req.url).to.equal('/app-beat');

                res.writeHead(200, { 'content-type': 'application/json' });
                res.end(JSON.stringify({ status: false }) + '\n');
            });

            server.listen(port, () => {

                BackEnd.heartBeat('token')
                    .then(() => {

                        server.close(() => {

                            done(new Error('this should have failed'));
                        });
                    })
                    .catch((err) => {

                        expect(err).to.exist();
                        server.close(() => {

                            done();
                        });
                    });
            });
        });
    });

    describe('attack', () => {

        it('should fail to an attack because of circular payload', { plan: 1, timeout: 10000 }, () => {

            const toSend = { hello: 'world' };
            toSend.toSend = toSend;

            return BackEnd.attack('session', toSend)
                .catch((err) => {

                    expect(err.message).to.includes('circular');
                    return Promise.resolve();
                });
        });

        it('should post an attack successfully', { plan: 6 }, (done) => {

            const toSend = JSON.stringify({ hello: 'world' });

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('POST');
                expect(req.url).to.equal('/attack');
                expect(req.headers.accept).to.equal('application/json');
                expect(req.headers['x-session-key']).to.equal('session');

                let body = '';

                req.on('data', (data) => {

                    body += data;
                });
                req.on('end', () => {

                    const payload = JSON.parse(body);
                    expect(payload.hello).to.equal('world');

                    res.writeHead(200, { 'content-type': 'application/json' });
                    res.end(JSON.stringify({ status: true }) + '\n');
                });
            });

            server.listen(port, () => {

                BackEnd.attack('session', toSend)
                    .then((response) => {

                        expect(response.status).to.be.true();
                        server.close(() => {

                            done();
                        });
                    })
                    .catch((err) => {

                        server.close(() => {

                            done(err);
                        });
                    });
            });
        });

        it('should fail to post an attack because of status: false in response', { plan: 6 }, (done) => {

            const toSend = { hello: 'world' };

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('POST');
                expect(req.url).to.equal('/attack');
                expect(req.headers.accept).to.equal('application/json');
                expect(req.headers['x-session-key']).to.equal('session');

                let body = '';

                req.on('data', (data) => {

                    body += data;
                });
                req.on('end', () => {

                    const payload = JSON.parse(body);
                    expect(payload.hello).to.equal('world');

                    res.writeHead(200, { 'content-type': 'application/json' });
                    res.end(JSON.stringify({ status: false }) + '\n');
                });
            });

            server.listen(port, () => {

                BackEnd.attack('session', toSend)
                    .then(() => {

                        server.close(() => {

                            done(new Error('this should have fail'));
                        });
                    })
                    .catch((err) => {

                        server.close(() => {

                            expect(err).to.exist();
                            done();
                        });
                    });
            });
        });

        it('should fail to post an attack because of err 500', { plan: 11, timeout: 30000 }, (done) => {

            const toSend = { hello: 'world' };

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('POST');
                expect(req.url).to.equal('/attack');
                expect(req.headers.accept).to.equal('application/json');
                expect(req.headers['x-session-key']).to.equal('session');

                let body = '';

                req.on('data', (data) => {

                    body += data;
                });
                req.on('end', () => {

                    const payload = JSON.parse(body);
                    expect(payload.hello).to.equal('world');

                    res.writeHead(500, { 'content-type': 'application/json' });
                    res.end(JSON.stringify({ status: false }) + '\n');
                });
            });

            server.listen(port, () => {

                BackEnd.attack('session', toSend)
                    .then(() => {

                        server.close(() => {

                            done(new Error('this should have fail'));
                        });
                    })
                    .catch((err) => {

                        server.close(() => {

                            expect(err).to.exist();
                            done();
                        });
                    });
            });
        });

    });

    describe('batch', () => {

        it('should post a batch successfully', { plan: 7 }, (done) => {

            const toSend = [1,2,3];

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('POST');
                expect(req.url).to.equal('/batch');
                expect(req.headers.accept).to.equal('application/json');
                expect(req.headers['x-session-key']).to.equal('session');

                let body = '';

                req.on('data', (data) => {

                    body += data;
                });
                req.on('end', () => {

                    const payload = JSON.parse(body);
                    expect(payload.batch).to.be.an.array();
                    expect(payload.batch).to.equal([1, 2, 3]);

                    res.writeHead(200, { 'content-type': 'application/json' });
                    res.end(JSON.stringify({ status: true }) + '\n');
                });
            });

            server.listen(port, () => {

                BackEnd.batch('session', toSend)
                    .then((response) => {

                        expect(response.status).to.be.true();
                        server.close(() => {

                            done();
                        });
                    })
                    .catch((err) => {

                        server.close(() => {

                            done(err);
                        });
                    });
            });
        });

        it('should fail to post a batch because of status: false in response', { plan: 6 }, (done) => {

            const toSend = [1,2,3];

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('POST');
                expect(req.url).to.equal('/batch');
                expect(req.headers.accept).to.equal('application/json');
                expect(req.headers['x-session-key']).to.equal('session');

                let body = '';

                req.on('data', (data) => {

                    body += data;
                });
                req.on('end', () => {

                    const payload = JSON.parse(body);
                    expect(payload.batch).to.be.an.array();

                    res.writeHead(200, { 'content-type': 'application/json' });
                    res.end(JSON.stringify({ status: false }) + '\n');
                });
            });

            server.listen(port, () => {

                BackEnd.batch('session', toSend)
                    .then(() => {

                        server.close(() => {

                            done(new Error('this should have fail'));
                        });
                    })
                    .catch((err) => {

                        server.close(() => {

                            expect(err).to.exist();
                            done();
                        });
                    });
            });
        });

        it('should fail to post a batch because of err 500', { plan: 11, timeout: 30000 }, (done) => {

            const toSend = [1,2,3];

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('POST');
                expect(req.url).to.equal('/batch');
                expect(req.headers.accept).to.equal('application/json');
                expect(req.headers['x-session-key']).to.equal('session');

                let body = '';

                req.on('data', (data) => {

                    body += data;
                });
                req.on('end', () => {

                    const payload = JSON.parse(body);
                    expect(payload.batch).to.be.an.array();

                    res.writeHead(500, { 'content-type': 'application/json' });
                    res.end(JSON.stringify({ status: false }) + '\n');
                });
            });

            server.listen(port, () => {

                BackEnd.batch('session', toSend)
                    .then(() => {

                        server.close(() => {

                            done(new Error('this should have fail'));
                        });
                    })
                    .catch((err) => {

                        server.close(() => {

                            expect(err).to.exist();
                            done();
                        });
                    });
            });
        });

    });

    describe('metrics', () => {

        it('should post an metrics successfully', { plan: 6 }, (done) => {

            const toSend = { hello: 'world' };

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('POST');
                expect(req.url).to.equal('/metrics');
                expect(req.headers.accept).to.equal('application/json');
                expect(req.headers['x-session-key']).to.equal('session');

                let body = '';

                req.on('data', (data) => {

                    body += data;
                });
                req.on('end', () => {

                    const payload = JSON.parse(body);
                    expect(payload.hello).to.equal('world');

                    res.writeHead(200, { 'content-type': 'application/json' });
                    res.end(JSON.stringify({ status: true }) + '\n');
                });
            });

            server.listen(port, () => {

                BackEnd.metrics('session', toSend)
                    .then((response) => {

                        expect(response.status).to.be.true();
                        server.close(() => {

                            done();
                        });
                    })
                    .catch((err) => {

                        server.close(() => {

                            done(err);
                        });
                    });
            });
        });
    });

    describe('exception', () => {

        it('should post an exception successfully', { plan: 6 }, (done) => {

            const toSend = { hello: 'world' };

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('POST');
                expect(req.url).to.equal('/sqreen_exception');
                expect(req.headers.accept).to.equal('application/json');
                expect(req.headers['x-session-key']).to.equal('session');

                let body = '';

                req.on('data', (data) => {

                    body += data;
                });
                req.on('end', () => {

                    const payload = JSON.parse(body);
                    expect(payload.hello).to.equal('world');

                    res.writeHead(200, { 'content-type': 'application/json' });
                    res.end(JSON.stringify({ status: true }) + '\n');
                });
            });

            server.listen(port, () => {

                BackEnd.exception('session', toSend)
                    .then((response) => {

                        expect(response.status).to.be.true();
                        server.close(() => {

                            done();
                        });
                    })
                    .catch((err) => {

                        server.close(() => {

                            done(err);
                        });
                    });
            });
        });

        it('should fail to post an exception because of status: false in response', { plan: 6 }, (done) => {

            const toSend = { hello: 'world' };

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('POST');
                expect(req.url).to.equal('/sqreen_exception');
                expect(req.headers.accept).to.equal('application/json');
                expect(req.headers['x-session-key']).to.equal('session');

                let body = '';

                req.on('data', (data) => {

                    body += data;
                });
                req.on('end', () => {

                    const payload = JSON.parse(body);
                    expect(payload.hello).to.equal('world');

                    res.writeHead(200, { 'content-type': 'application/json' });
                    res.end(JSON.stringify({ status: false }) + '\n');
                });
            });

            server.listen(port, () => {

                BackEnd.exception('session', toSend)
                    .then(() => {

                        server.close(() => {

                            done(new Error('this should have fail'));
                        });
                    })
                    .catch((err) => {

                        server.close(() => {

                            expect(err).to.exist();
                            done();
                        });
                    });
            });
        });

        it('should fail to post an exception because of err 500', { plan: 11, timeout: 30000 }, (done) => {

            const toSend = { hello: 'world' };

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('POST');
                expect(req.url).to.equal('/sqreen_exception');
                expect(req.headers.accept).to.equal('application/json');
                expect(req.headers['x-session-key']).to.equal('session');

                let body = '';

                req.on('data', (data) => {

                    body += data;
                });
                req.on('end', () => {

                    const payload = JSON.parse(body);
                    expect(payload.hello).to.equal('world');

                    res.writeHead(500, { 'content-type': 'application/json' });
                    res.end(JSON.stringify({ status: false }) + '\n');
                });
            });

            server.listen(port, () => {

                BackEnd.exception('session', toSend)
                    .then(() => {

                        server.close(() => {

                            done(new Error('this should have fail'));
                        });
                    })
                    .catch((err) => {

                        server.close(() => {

                            expect(err).to.exist();
                            done();
                        });
                    });
            });
        });

    });

    describe('commands', () => {

        it('should post a commands successfully', { plan: 6 }, (done) => {

            const toSend = { hello: 'world' };

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('POST');
                expect(req.url).to.equal('/commands');
                expect(req.headers.accept).to.equal('application/json');
                expect(req.headers['x-session-key']).to.equal('session');

                let body = '';

                req.on('data', (data) => {

                    body += data;
                });
                req.on('end', () => {

                    const payload = JSON.parse(body);
                    expect(payload.hello).to.equal('world');

                    res.writeHead(200, { 'content-type': 'application/json' });
                    res.end(JSON.stringify({ status: true }) + '\n');
                });
            });

            server.listen(port, () => {

                BackEnd.commands('session', toSend)
                    .then((response) => {

                        expect(response.status).to.be.true();
                        server.close(() => {

                            done();
                        });
                    })
                    .catch((err) => {

                        server.close(() => {

                            done(err);
                        });
                    });
            });
        });

        it('should fail to post a commands because of status: false in response', { plan: 6 }, (done) => {

            const toSend = { hello: 'world' };

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('POST');
                expect(req.url).to.equal('/commands');
                expect(req.headers.accept).to.equal('application/json');
                expect(req.headers['x-session-key']).to.equal('session');

                let body = '';

                req.on('data', (data) => {

                    body += data;
                });
                req.on('end', () => {

                    const payload = JSON.parse(body);
                    expect(payload.hello).to.equal('world');

                    res.writeHead(200, { 'content-type': 'application/json' });
                    res.end(JSON.stringify({ status: false }) + '\n');
                });
            });

            server.listen(port, () => {

                BackEnd.commands('session', toSend)
                    .then(() => {

                        server.close(() => {

                            done(new Error('this should have fail'));
                        });
                    })
                    .catch((err) => {

                        server.close(() => {

                            expect(err).to.exist();
                            done();
                        });
                    });
            });
        });

        it('should fail to post a commands because of err 500', { plan: 11, timeout: 30000 }, (done) => {

            const toSend = { hello: 'world' };

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('POST');
                expect(req.url).to.equal('/commands');
                expect(req.headers.accept).to.equal('application/json');
                expect(req.headers['x-session-key']).to.equal('session');

                let body = '';

                req.on('data', (data) => {

                    body += data;
                });
                req.on('end', () => {

                    const payload = JSON.parse(body);
                    expect(payload.hello).to.equal('world');

                    res.writeHead(500, { 'content-type': 'application/json' });
                    res.end(JSON.stringify({ status: false }) + '\n');
                });
            });

            server.listen(port, () => {

                BackEnd.commands('session', toSend)
                    .then(() => {

                        server.close(() => {

                            done(new Error('this should have fail'));
                        });
                    })
                    .catch((err) => {

                        server.close(() => {

                            expect(err).to.exist();
                            done();
                        });
                    });
            });
        });

    });

    describe('rulespack', () => {

        it('get a rulespack', { plan: 4 }, (done) => {

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('GET');
                expect(req.url).to.equal('/rulespack');
                expect(req.headers['x-session-key']).to.equal('session');

                res.writeHead(200, { 'content-type': 'application/json' });
                res.end(JSON.stringify({ status: true }) + '\n');
            });

            server.listen(port, () => {

                BackEnd.rulespack('session')
                    .then((response) => {

                        expect(response).to.exist();
                        server.close(() => {

                            done();
                        });
                    })
                    .catch((err) => {

                        server.close(() => {

                            done(err);
                        });
                    });
            });
        });

        it('should fail to get rulespack because of error 500', { plan: 5, timeout: 30000 }, (done) => {

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('GET');
                expect(req.url).to.equal('/rulespack');

                res.writeHead(500, { 'content-type': 'application/json' });
                res.end(JSON.stringify({ status: true }) + '\n');
            });

            server.listen(port, () => {

                BackEnd.rulespack('token')
                    .then(() => {

                        server.close(() => {

                            done(new Error('this should have failed'));
                        });
                    })
                    .catch((err) => {

                        expect(err).to.exist();
                        server.close(() => {

                            done();
                        });
                    });
            });
        });

        it('should fail to logout a user because of false status in payload', { plan: 3 }, (done) => {

            const server = Http.createServer((req, res) => {

                expect(req.method).to.equal('GET');
                expect(req.url).to.equal('/rulespack');

                res.writeHead(200, { 'content-type': 'application/json' });
                res.end(JSON.stringify({ status: false }) + '\n');
            });

            server.listen(port, () => {

                BackEnd.rulespack('token')
                    .then(() => {

                        server.close(() => {

                            done(new Error('this should have failed'));
                        });
                    })
                    .catch((err) => {

                        expect(err).to.exist();
                        server.close(() => {

                            done();
                        });
                    });
            });
        });

    });

    describe('_LoggedRp', () => {

        it('should reject unhandled http verbs', { plan: 1, timeout: 15000 }, () => {

            return BackEnd._LoggedRp({ method: 'PATCH' })
                .catch((err) => {

                    expect(err.message).to.equal('unhandled verb PATCH');
                    return Promise.resolve();
                });
        });
    });
});
