/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Proxyquire = require('proxyquire');

describe('patcher', () => {

    describe('_patchObject', () => {

        it('should not patch null object', { plan: 2 }, (done) => {

            expect(require('../../../lib/instrumentation/patcher')._patchObject(null)).to.not.exist();
            expect(require('../../../lib/instrumentation/patcher')._patchObject('empty')).to.not.exist();
            done();
        });
    });

    describe('patchModule', () => {

        it('should wrap a named constructor', { plan: 5 }, (done) => {

            const fct = function F(x) {

                this.x = x;
                Object.freeze(this);
            };
            fct.prototype.action = function () {

                return 2 * this.x;
            };
            fct.prototype.action2 = function () {

                return 2 * this.x;
            };

            fct.prototype.__defineGetter__('VERSION', () => {

                return function () {};
            });

            Object.defineProperty(fct, 'fail', {
                enumerable: true,
                get: function () {

                    throw new Error();
                }
            });

            fct.prototype.action2.__wrapped = true;
            const module = { 'a': fct };
            const Patcher = require('../../../lib/instrumentation/patcher');

            Patcher.patchModule(module, { name: 'knex', version: '1.0.0', relativePath: 'lib/index.js' });

            const res = new module.a(10);
            expect(res).to.be.an.instanceof(fct);
            expect(res.x).to.equal(10);
            expect(res.action()).to.equal(20);
            expect(res.action.__wrapped).to.be.true();
            expect(res.__proto__.action.__wrapped).to.be.true();


            done();
        });

        it('should trigger special cased', { plan: 3 }, (done) => {

            const Patcher = require('../../../lib/instrumentation/patcher');

            const obj = {};
            obj.nu = null;
            Object.defineProperty(obj, 'subob', {
                enumerable: true,
                configurable: true,
                get: function () {

                    return { a: function () {} };
                }
            });

            obj.x = undefined;

            Patcher.patchModule(obj, { name: 'obj', version: '1.0.0', relativePath: 'lib/index.js' });

            expect(obj.nu === null).to.be.true();
            expect(obj.subob.a).to.exist();
            expect(obj.subob.a.__wrapped).to.be.true();
            done();

        });

        it('should call patchFunction', { plan: 2 }, (done) => {

            const Patcher = require('../../../lib/instrumentation/patcher');
            const fct = function () {};
            fct.prototype = null;
            const obj = {
                a: function () { },
                b: fct,
                c: 1
            };

            Patcher.patchModule(obj, {});
            expect(obj.a.__wrapped).to.be.true();
            expect(obj.b.__wrapped).to.be.true();
            done();
        });

        it('should call patchFunction', { plan: 2 }, (done) => {

            const Patcher = require('../../../lib/instrumentation/patcher');
            const fct = function () {};
            fct.prototype.action = function () {};
            const obj = {
                a: fct
            };

            Patcher.patchModule(obj, {});
            expect(obj.a.__wrapped).to.be.true();
            expect(obj.a.prototype.action.__wrapped).to.be.true();
            done();
        });

        it('should call patchFunction on weirdly defined methods', { plan: 6 }, (done) => {

            const Patcher = require('../../../lib/instrumentation/patcher');
            let obj = function () {};

            obj.subOb = { a: function () {} };

            Object.defineProperty(obj, 'b', {
                configurable: true,
                enumerable: true,
                get: function () {

                    const fct = function () {};

                    fct.a = 1;
                    fct.f = function () {};

                    return fct;
                }
            });

            Object.defineProperty(obj, 'c', {
                configurable: true,
                enumerable: true,
                get: function () {

                    return 10;
                }
            });

            Object.defineProperty(obj, 'd', {
                configurable: true,
                enumerable: true,
                value: 5
            });

            Object.defineProperty(obj, 'f', {
                configurable: true,
                enumerable: true,
                get: function () {

                    const fct = function () {};

                    fct.a = 1;
                    fct.f = function () {};
                    fct.prototype = null;

                    return fct;
                }
            });

            obj.__proto__.e = 1;

            obj = Patcher.patchModule(obj, {});
            expect(obj.__wrapped).to.be.true();
            // expect(obj.subOb.a.__wrapped).to.be.true();
            expect(obj.b.__wrapped).to.be.true();
            expect(obj.b.a).to.equal(1);
            expect(obj.b.f.__wrapped).to.be.true();
            expect(obj.c).to.equal(10);
            expect(obj.d).to.equal(5);
            done();
        });

        it('should call patchFunction', { plan: 1 }, (done) => {

            const Patcher = require('../../../lib/instrumentation/patcher');
            const fct = function () {};
            fct.prototype = null;
            const obj = fct;

            const pat = Patcher.patchModule(obj, {});
            expect(pat.__wrapped).to.be.true();
            done();
        });

        it('should call patchFunction', { plan: 1 }, (done) => {

            const Patcher = require('../../../lib/instrumentation/patcher');
            const fct = function () {};
            fct.prototype = null;
            const obj = fct;

            const pat = Patcher.patchModule(obj, {});
            expect(pat.__wrapped).to.be.true();
            done();
        });

        it('should not do anything', { plan: 0 }, (done) => {

            const Patcher = require('../../../lib/instrumentation/patcher');

            Patcher.patchModule(null, {});
            done();
        });

        it('should ony patchFunction', { plan: 1 }, (done) => {

            const MockedPatcher = Proxyquire('../../../lib/instrumentation/patcher', {
                './functionPatcher': {
                    patchFunction: function (holder, key) {

                        holder[key].__wrapped = true;
                    }
                }
            });
            const obj = function () { };
            obj.prototype = null;

            MockedPatcher.patchModule(obj, {});
            expect(obj.__wrapped).to.be.true();
            done();
        });

        it('should ony patchFunction and empty prototype', { plan: 1 }, (done) => {

            const MockedPatcher = Proxyquire('../../../lib/instrumentation/patcher', {
                './functionPatcher': {
                    patchFunction: function (holder, key) {

                        holder[key].__wrapped = true;
                    }
                }
            });
            const obj = function () { };

            MockedPatcher.patchModule(obj, {});
            expect(obj.__wrapped).to.be.true();
            done();
        });

        it('should ony patchFunction and empty prototype', { plan: 1 }, (done) => {

            const MockedPatcher = Proxyquire('../../../lib/instrumentation/patcher', {
                './functionPatcher': {
                    patchFunction: function (holder, key) {

                        holder[key].__wrapped = true;
                    }
                }
            });
            const fct = function () { };
            fct.prototype = null;
            Object.setPrototypeOf(fct, null);
            const obj = {
                f: fct
            };

            MockedPatcher.patchModule(obj, {});
            expect(obj.__wrapped).to.not.exist();
            done();
        });

        it('should ony patchFunction and prototype', { plan: 2 }, (done) => {

            const MockedPatcher = Proxyquire('../../../lib/instrumentation/patcher', {
                './functionPatcher': {
                    patchFunction: function (holder, key) {

                        holder[key].__wrapped = true;
                    }
                }
            });
            let obj = function () { };
            obj.prototype.do = function () {};

            obj = MockedPatcher.patchModule(obj, {});
            expect(obj.__wrapped).to.be.true();
            expect((new obj()).do.__wrapped).to.be.true();
            done();
        });

        it('should patch events', { plan: 2 }, (done) => {

            const Patcher = require('../../../lib/instrumentation/patcher');
            let Event = require('events');
            Event = Patcher.patchModule(Event, { name: 'events' });

            expect(Event.__wrapped).to.be.true();
            expect(Event.prototype.emit.__wrapped).to.be.true();

            done();
        });

    });
});

