/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Proxyquire = require('proxyquire');

describe('Patch', () => {

    describe('_report', () => {

        it('should not report an attack', { plan: 0 }, (done) => {

            const Report = require('../../../lib/instrumentation/patch')._report;
            Report();
            done();
        });

        it('should report an attack', { plan: 6 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl.rule_name).to.equal('rule');
                    expect(pl.rulespack_id).to.equal('0');
                    expect(pl.infos).to.equal('infos');
                    expect(pl.request.scheme).to.equal('http');
                    expect(pl.client_ip).to.equal('168.0.0.1');
                    expect(pl.headers).to.equal([]);
                    done();
                }
            })._report;

            Report({
                rule: {
                    name: 'rule',
                    rulesPack: '0'
                },
                record: 'infos',
                params: 'params',
                session: {
                    req: {
                        req: 'req',
                        connection: {
                            remoteAddress: '168.0.0.1'
                        }
                    }
                }
            });
        });

        it('should report an attack', { plan: 3 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl.rule_name).to.equal('rule');
                    expect(pl.rulespack_id).to.equal('0');
                    expect(pl.headers).to.not.exist();
                    done();
                }
            })._report;

            Report({
                rule: {
                    name: 'rule',
                    rulesPack: '0'
                },
                record: 'infos',
                params: 'params',
                session: {}
            });
        });

        it('should report an attack in whitelisted path', { plan: 8 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl.rule_name).to.equal('rule');
                    expect(pl.rulespack_id).to.equal('0');
                    expect(pl.infos).to.equal('infos');
                    // expect(pl.params.req).to.equal('req');
                    expect(pl.request.scheme).to.equal('http');
                    expect(pl.client_ip).to.equal('127.0.0.1');
                    expect(pl.block).to.equal(false);
                    expect(pl.whitelist_match).to.equal('/admin/');
                    expect(pl.headers).to.equal([]);
                    done();
                }
            })._report;

            Report({
                rule: {
                    name: 'rule',
                    rulesPack: '0'
                },
                record: 'infos',
                params: 'params',
                session: {
                    req: {
                        headers: {
                            'x-forwarded-for': '192.168.0.1',
                            host: 'localhost:3000'
                        },
                        req: 'req',
                        connection: {
                            remoteAddress: '127.0.0.1'
                        },
                        rawHeaders: []
                    }
                }
            }, null, '/admin/');
        });

        it('should report an attack', { plan: 5 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl.rule_name).to.equal('rule');
                    expect(pl.rulespack_id).to.equal('0');
                    expect(pl.infos).to.equal('infos');
                    // expect(pl.params.req).to.equal('req');
                    expect(pl.request.scheme).to.equal('http');
                    expect(pl.client_ip).to.equal('127.0.0.1');
                    done();
                }
            })._report;

            Report({
                rule: {
                    name: 'rule',
                    rulesPack: '0'
                },
                record: 'infos',
                params: 'params',
                session: {
                    req: {
                        req: 'req',
                        connection: {
                            remoteAddress: '127.0.0.1'
                        }
                    }
                }
            });
        });

        it('should report an attack', { plan: 1 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl).to.exist();
                    done();
                }
            })._report;

            Report({
                rule: {}
            });
        });
        it('should report an attack', { plan: 1 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl).to.exist();
                    done();
                }
            })._report;

            Report({
                rule: {},
                session: {}
            });
        });
        it('should report an attack', { plan: 1 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl).to.exist();
                    done();
                }
            })._report;

            Report({
                rule: {},
                session: {
                    req: {
                        headers: {},
                        connection: {},
                        rawHeaders: [
                            'x-forwarded-for', 'a',
                            'x-cluster-client-ip', 'b'
                        ]
                    }
                }
            });
        });
    });

    describe('_actOnCbResult', () => {

        it('should not skip even if the rule is in test because of SQREEN_BLOCK_ALL', { plan: 1 }, (done) => {

            const Patch = Proxyquire('../../../lib/instrumentation/patch', {
                '../config': {
                    getConfig: function () {

                        return {
                            block_all_rules: true
                        };
                    }
                }
            });

            const res = Patch._actOnCbResult([{ status: 'skip', rule: { test: true } }]);
            expect(res.status).to.equal('skip');
            done();
        });

        it('should do nothing since we are in a whitelist', { plan: 1 }, (done) => {

            const Patch = Proxyquire('../../../lib/instrumentation/patch', {
                'continuation-local-storage': {
                    getNamespace: function () {

                        return {
                            get: function () {

                                return {
                                    __sqreen_url: '/home'
                                };
                            }
                        };
                    }
                },
                './utils': {
                    pathIsWhiteListed: function () {

                        return true;
                    }
                }
            });

            const res = Patch._actOnCbResult([{ status: 'skip', rule: { test: true } }]);
            expect(res).to.not.exist();
            done();
        });

        it('should do nothing since we are in a whitelist', { plan: 1 }, (done) => {

            const Patch = Proxyquire('../../../lib/instrumentation/patch', {
                'continuation-local-storage': {
                    getNamespace: function () {

                        return {
                            get: function () {

                                return {
                                    url: '/home'
                                };
                            }
                        };
                    }
                }
            });

            Patch.whiteListPath(['/hom']);
            const res = Patch._actOnCbResult([{ status: 'skip', rule: { test: true } }]);
            expect(res).to.not.exist();
            done();
        });
    });

    describe('removeAllCallbacks', () => {

        it('should remove all callbacks from patches', { plan: 4 }, (done) => {

            const Patch = Proxyquire('../../../lib/instrumentation/patch', {
                './director': {
                    register: function () { }
                }
            });

            const p1 = new Patch({ a: function (){} }, 'a');
            p1.hasCbs = true;
            p1.preCbs.push({ x: 1 });

            expect(p1.hasCbs).to.be.true();
            expect(p1.preCbs).to.have.length(1);
            Patch.removeAllCallbacks();
            expect(p1.hasCbs).to.be.false();
            expect(p1.preCbs).to.have.length(0);
            done();
        });
    });
});
