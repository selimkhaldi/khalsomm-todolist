/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
/**
 * This is the list of the known commands and the related handlers
 */
'use strict';
const Logger = require('../logger');
const BackEnd = require('../backend');
const Agent = require('../agent');
const Features = require('./features');

const commands = {
    mock: function () { // For testing purpose

        return Promise.resolve();
    },
    mock_fail: function () { // For testing purpose

        return Promise.reject();
    },
    instrumentation_enable: function (params, uuid) {

        Logger.DEBUG(`enables instrumentation with uuid ${uuid}`);
        return commands.rules_reload();
    },
    rules_reload: function (params, uuid) {

        Logger.DEBUG(`reload rulespack with uuid ${uuid}`);

        if (!Agent.SESSION_ID()) {
            return Promise.reject(new Error('agent is offline'));
        }
        return BackEnd.rulespack(Agent.SESSION_ID())
            .then((response) => {

                // const pack_id = response.pack_id; // TODO: track it
                const rules = response.rules;
                for (let i = 0; i < rules.length; ++i) {
                    rules[i].rulesPack = response.pack_id;
                }
                Logger.INFO(`got a new rulepack with ${rules.length} rules`);

                // remove all callbacks everywhere before reloading rules
                const Patch = require('../instrumentation/patch');
                Patch.removeAllCallbacks();

                const Rules = require('../rules'); // load here and not at the beginning of the script to prevent circular import issue
                const result = Rules.enforceRuleList(rules);

                if (!result) {
                    return Promise.reject(new Error(`invalid rulespack: ${response.pack_id}`));
                }

                return response.pack_id;
            });
    },
    instrumentation_remove: function (params, uuid) {

        Logger.INFO(`disabling instrumentation with uui ${uuid}`);
        const Patch = require('../instrumentation/patch');
        Patch.removeAllCallbacks();
        return Promise.resolve();
    },
    features_change: function (params, uuid) {

        Logger.INFO(`changing features to ${JSON.stringify(params)} with id ${uuid}`);
        return Promise.resolve(Features.change(params));
    },
    features_get: function (params, uuid) {

        Logger.INFO(`getting features to ${JSON.stringify(params)} with id ${uuid}`);
        return Promise.resolve(Features.read());
    },
    paths_whitelist: function (params, uuid) {

        if (!params[0] || !Array.isArray(params[0])) {
            return Promise.reject(new Error('invalid params'));
        }
        Logger.INFO(`Whitelisting paths ${params[0].join(',')} with uui ${uuid}`);
        const Patch = require('../instrumentation/patch');
        Patch.whiteListPath(params[0]);
        return Promise.resolve();
    }
};
module.exports = commands;
