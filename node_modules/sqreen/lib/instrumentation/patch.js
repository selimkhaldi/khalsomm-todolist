/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const CB_STATUS = require('../enums/cbReturn').STATUS;
const Director = require('./director');
const CLS = require('continuation-local-storage');
const Logger = require('../logger');
const RuleUtil = require('../rules/rules-callback/utils');
const Attack = require('../constructors/attack');
const ReportUtil = require('./reportUtil');
const Metrics = require('../metric');
const Config = require('../config').getConfig() || {};
const Exception = require('../exception');
const Utils = require('../util');
const InstrumentationUtils = require('./utils');

const HeaderClaims = Utils.headerClaims;
let WHITELISTED_PATHS = [];
const getHeaders = function (req) {

    if (!req.rawHeaders) {
        return [];
    }

    const result = [];
    const raw = req.rawHeaders;
    for (let i = 0; i < raw.length; ++i) {
        if (HeaderClaims.indexOf(raw[i].toLowerCase()) > -1) {
            result.push([raw[i], raw[i + 1]]);
        }
    }
    return result;
};

const report = function (cbResult, err, whitelistMatch) {

    // TODO: put in setImmediate ?
    if (!cbResult) {
        return;
    }

    const session = cbResult.originalSession || cbResult.session || {};


    const atk = {
        rule_name: cbResult.rule && cbResult.rule.name,
        rulespack_id: cbResult.rule && cbResult.rule.rulesPack,
        infos: cbResult.record,
        params: session.req && Object.assign(ReportUtil.mapRequest(session.req), {
            scheme: session.req.scheme
        }),
        request: session.req && ReportUtil.mapRequest(session.req),

        block: cbResult.rule && cbResult.rule.block,
        test: cbResult.rule && cbResult.rule.test,
        beta: cbResult.rule && cbResult.rule.beta,
        learning: cbResult.rule && cbResult.rule.learning,

        headers: session.req && getHeaders(session.req)
    };

    if (whitelistMatch) {
        atk.block = false;
        atk.whitelist_match = whitelistMatch;
    }

    atk.client_ip = Utils.getXFFOrRemoteAddress(session.req);

    atk.request = atk.request || {};
    atk.request.addr = atk.client_ip;

    (new Attack(atk, err)).report();
};

const observe = function (cbResult, date) {

    // It does not need to be done right now
    setImmediate(() => {

        const observations = cbResult.observations;
        Metrics.addObservations(observations, date);
    });
};

const performRecordAndObservation = function (resultList, whitelistMatch) {

    const date = new Date();
    const err = new Error();
    setImmediate(() => {

        for (let i = 0; i < resultList.length; ++i) {
            const result = resultList[i];
            if (result.record) {
                report(result, err, whitelistMatch);
            }

            if (result.observations) {
                observe(result, date);
            }
        }
    });
};

const actOnCbResult = function (resultList) {

    // modify args one day ? https://github.com/sqreen/Wiki/wiki/Sqreen-callbacks#pre

    if (resultList.length === 0) {
        return null;
    }
    const rawSession = CLS.getNamespace('sqreen_session') || { get: () => null };
    // sometimes, the session is given from the callback: it is particular for the situation where the callback is placed on the eventEmitter and therefore executed BEFORE tracing is enabled
    // a solution would be to place tracing before on the request lifecyle but it would not be the smartest move (why place a tracing if the request/respose objects are always available and might have to be dropped ?)
    const session = InstrumentationUtils.getListSession(resultList) || { req: rawSession.get('req'), res: rawSession.get('res') };

    const path = session.req && ( session.req.__sqreen_url || session.req.url) || '';
    const whitelistMatch = InstrumentationUtils.pathIsWhiteListed(path, WHITELISTED_PATHS);
    performRecordAndObservation(resultList, whitelistMatch);

    if (whitelistMatch) {
        return null;
    }

    for (let i = 0; i < resultList.length; ++i) {

        const result = resultList[i];
        const rule = result.rule || {};

        if (result.status) {

            Logger.INFO(`Sqreen callback returned status ${result.status}`);
            Logger.DEBUG(`Sqreen callback result: ${result}`);

            if (!rule.test || Config.block_all_rules) {
                if (result.status === CB_STATUS.RAISE) {

                    if (session.req && session.res) {
                        RuleUtil.dropRequest(['', session.req, session.res]);
                        return { status: CB_STATUS.SKIP };
                    }
                    // throw new Error('Sqreen has blocked an attack'); // TODO: see with JB what is the right strategy here for once
                }
                if (result.status === CB_STATUS.SKIP) {
                    return result;
                }
            }
        }
    }
    return null;
};

const runUniqueCb = function (method, args, value, rule, selfObject, session) {

    try {
        const result = method(args, value, rule, selfObject, session) || {};
        result.session = session;
        result.rule = rule;
        result.params = { args, value };
        return result;
    }
    catch (e) {

        let err = e;
        if (!(err instanceof Error)) {
            err = new Error(err);
        }

        Logger.DEBUG(`cb has failed with ${err}`);
        rule = rule || {};
        err.ruleName = rule.name;
        err.rulesPack = rule.rulesPack;
        Exception.report(err).catch(() => {});
    }
};

const runCbs = function (list, args, value, selfObject, kind) {

    if (process.__sqreen_cb) { // of the lock is present
        return null;
    }
    const rawSession = CLS.getNamespace('sqreen_session') || { get: () => null };

    const session = {
        req: rawSession.get('req'),
        res: rawSession.get('res'),
        raw: rawSession
    };

    const result = [];
    for (let i = 0; i < list.length; ++i) {
        if (!list[i].method) {
            continue;
        }
        process.__sqreen_cb = true; // place a lock: two callbacks cannot run at the same time
        const rs = runUniqueCb(list[i].method, args, value, list[i].rule, selfObject, session);
        const rule = list[i].rule || {};
        Metrics.addObservations([
            [
                `${rule.pack_id}/${rule.name}/${kind}`,
                1
            ]
        ], new Date());
        if (rs) {
            result.push(rs);
        }
        process.__sqreen_cb = false; // remove lock
    }
    return result;
};

const ALL_PATCHES = [];
class Patch {

    constructor(original, moduleIdentity, holderName, key) {

        this.original = original;
        this.moduleIdentity = moduleIdentity;
        this.holderName = holderName;
        this.key = key;

        this.preCbs = [];
        this.failCbs = [];
        this.postCbs = [];
        this.hasCbs = false;

        this.instrumented = function () {};

        this.build();
        ALL_PATCHES.push(this);
    }

    originalCall(selfObj, args) {

        if (selfObj && Object.getPrototypeOf(selfObj) && Object.getPrototypeOf(selfObj).hasOwnProperty('constructor') && selfObj.constructor === this.original && !this.__sqreen_constructed) {
            const res = new (Function.prototype.bind.apply(this.original, [null].concat(Array.from(args))))();
            if (Object.isExtensible(res)) {
                Object.defineProperty(res, '__sqreen_constructed', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: true
                });
            }
            return res;
        }
        return this.original.apply(selfObj, args);
    }

    safeOriginalCall(selfObj, args) {

        try {
            return this.originalCall(selfObj, args);
        }
        catch (err) {
            err.__sqreen = true;
            return err;
        }
    }

    register() {

        const self = this;
        Director.register({ // register the function for possible instrumentation
            moduleName: this.moduleIdentity.name,
            version: this.moduleIdentity.version,
            file: this.moduleIdentity.relativePath,
            methodName: this.holderName + (this.holderName ? ':' : '') + this.key,
            updateCallback: function (params) {

                Logger.DEBUG(`updating patch for ${self.moduleIdentity.name}/${self.moduleIdentity.relativePath}.${self.holderName + ':' + self.key}`);
                self.preCbs = params.preCbs || self.preCbs;
                self.failCbs = params.failCbs || self.failCbs;
                self.postCbs = params.postCbs || self.postCbs;
                self.hasCbs = (self.preCbs.length > 0 || self.failCbs.length > 0 || self.postCbs.length > 0);
            }
        });
    }

    runPre(arg, value, selfObject) {

        return runCbs(this.preCbs, arg, value, selfObject, 'pre');
    }

    runFail(arg, value, selfObject) {

        return runCbs(this.failCbs, arg, value, selfObject, 'fail');
    }

    runPost(arg, value, selfObject) {

        return runCbs(this.postCbs, arg, value, selfObject, 'post');
    }

    build() {

        const self = this;
        this.instrumented = function () {

            if (!self.hasCbs || process.__sqreen_cb) {
                return self.originalCall(this, arguments);
            }

            const preAction = actOnCbResult(self.runPre(arguments, null, this));
            if (preAction && preAction.status === CB_STATUS.SKIP) {
                return preAction.newReturnValue;
            }

            const result = self.safeOriginalCall(this, arguments);

            if (result instanceof Error && result.__sqreen) {
                const failAction = actOnCbResult(self.runFail(arguments, result, this));
                if (failAction && failAction.status === CB_STATUS.SKIP) {
                    return failAction.newReturnValue;
                }
                throw result;
            }

            const postAction = actOnCbResult(self.runPost(arguments, result, this));
            if (postAction && postAction.status === CB_STATUS.SKIP) {
                return postAction.newReturnValue;
            }
            return result;
        };

        Object.setPrototypeOf(this.instrumented, Object.getPrototypeOf(this.original));
        if (this.original.prototype) {
            Object.setPrototypeOf(this.instrumented.prototype, Object.getPrototypeOf(this.original.prototype));
        }

        const memberList = Object.getOwnPropertyNames(this.original);
        for (let i = 0; i < memberList.length; ++i) {
            Object.defineProperty(this.instrumented, memberList[i], Object.getOwnPropertyDescriptor(this.original, memberList[i]));
        }
        this.register();
    }
}

module.exports = Patch;
module.exports._runCbs = runCbs;
module.exports._report = report;
module.exports._actOnCbResult = actOnCbResult;
module.exports.removeAllCallbacks = function () {

    Director.clearWaitings();
    for (let i = 0; i < ALL_PATCHES.length; ++i) {
        const patch = ALL_PATCHES[i];
        patch.hasCbs = false;
        patch.preCbs = [];
        patch.failCbs = [];
        patch.postCbs = [];
    }
};

module.exports.whiteListPath = function (pathList) {

    WHITELISTED_PATHS = pathList;
};
