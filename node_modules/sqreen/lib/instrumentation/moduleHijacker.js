/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Logger = require('../logger');
const Module = require('module');
const Patcher = require('./patcher');
const ModuleIdentity = require('./moduleIdentity');
const Tracing = require('./hooks/tracing');
const Hooks = require('./hooks');
const Templateengines = require('./templateEngines');

const DO_NOT_HJ = [
    'continuation-local-storage',
    'shimmer',
    'bindings', // FIXME: this module will access weird stacktraces...
    'tapable'
];

const load = Module._load;

const cache = {};

module.exports.enable = function () {

    Logger.DEBUG('Sqreen enables instrumentation of modules');

    Module._load = function (request, parent) { // replace the Module._load method

        const noDeprecation = process.noDeprecation;
        process.noDeprecation = true; // prevent depreciation messages to be shown during patching

        // https://github.com/opbeat/require-in-the-middle/blob/master/index.js indicates that an error might appears in case of circular dependencies... to be watched

        const file = Module._resolveFilename(request, parent); // only unique identifier of a module: its full path from the system root

        if (cache[file]) { // have we already patched this file ?
            return cache[file];
        }

        let loadedModule = load.apply(this, arguments); // effective load of the module

        if (DO_NOT_HJ.indexOf(request) > -1) {
            return loadedModule;
        }

        const identity = ModuleIdentity.scan(request, parent);


        if (request === 'http') { // specific hook to trace http requests
            Tracing.enable(loadedModule, identity);
        }

        if (!identity.internal && (!(request.indexOf('./') > -1 ) || identity.forceHj)) { // we do not patch modules that are not external or core FIXME: we do not patch internal exports to prevent incoherences
            try {
                loadedModule = Patcher.patchModule(loadedModule, identity);
            }
            catch (err) {
                Logger.DEBUG(`could not patch module ${request}: ${err.message}`);
            }
        }

        cache[file] = loadedModule; // cache the result for later

        if (Hooks[request]) {
            Hooks[request](identity);
        }

        Templateengines.hook(request);

        process.noDeprecation = noDeprecation;
        return loadedModule;
    };
};
