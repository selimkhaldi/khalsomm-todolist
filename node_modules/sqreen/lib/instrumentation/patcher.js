/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const noconsole = {
    pg: ['native'],
    knex: ['VERSION', 'Promise']
};

const Logger = require('../logger');

const FunctionPatcher = require('./functionPatcher');

const MAX_DEPTH = 3;

const seenMap = new WeakMap();

const log = global.console.log;
const err = global.console.error;

// externalize try/catch (optim)
const safeDefineProperty = function (object, key, descriptor) {

    try {
        return Object.defineProperty(object, key, descriptor);
    }
    catch (_) {
        // right know we ignore this... it throws when we try to redefine non configurable properties
    }
    return object;
};


const patchObject = module.exports._patchObject = function (object, identity, objectName, depth) {

    if (!object) {
        return;
    }

    if (!(typeof object === 'object' || typeof object === 'function')) {
        return;
    }

    const seen = seenMap.get(object) || {};
    if (seen[identity.name] >= MAX_DEPTH) {
        return;
    }
    if (seen[identity.name]) {
        seen[identity.name]++;
    }
    else {
        seen[identity.name] = 1;
    }

    seenMap.set(object, seen);

    objectName = objectName || '';

    depth = depth || 0;

    if (depth > MAX_DEPTH) {
        return;
    }

    Logger.DEBUG(`patching module ${identity.name}@${identity.version}/${identity.relativePath} on ${Object.keys(object)}`);

    const propertyNames = Object.getOwnPropertyNames(object).filter((name) => !(objectName.indexOf('prototype') > -1 && name === 'constructor')); // we do not want to patch constructors in prototypes to keep the prototype chain...

    for (let i = 0; i < propertyNames.length; ++i) {
        const key = propertyNames[i];
        const name = key ? key + '.' : '';
        const oName = objectName ? objectName + '.' : '';

        global.console.log = log;
        global.console.error = err;

        if (noconsole[identity.name] && noconsole[identity.name].indexOf(key) > -1) {
            global.console.log = function () {};
            global.console.error = function () {};
        }

        const descriptor = Object.getOwnPropertyDescriptor(object, key);

        if (descriptor.get) {
            // FIXME: need to patch the result of the closure to be paranoid for real when there is a getter

            const getter = descriptor.get;
            const newGetter = function () {

                const result = getter.apply(this, arguments);
                if (typeof result === 'function') {
                    const holder = {};
                    holder.got = result;
                    patchObject(holder, identity, key);
                    return holder.got;
                }
                if (typeof result === 'object') {
                    patchObject(result, identity, key);
                    return result;
                }
                return result;
            };
            descriptor.get = newGetter;
            object = safeDefineProperty(object, key, descriptor);
        }
        else if (descriptor.value) {

            if (object[key].__wrapped) {
                continue;
            }

            if (typeof object[key] === 'function') {
                FunctionPatcher.patchFunction(object, key, identity, objectName);
                if (object[key].prototype) {
                    patchObject(object[key].prototype, identity, oName + name + 'prototype', depth + 1);
                }
                patchObject(object[key], identity, oName + key, depth + 1);
            }
        }
    }
};

module.exports.patchModule = function (module, identity) {

    let returnValue = module;

    if (!module) {
        return;
    }

    Logger.DEBUG(`patching module ${identity.name}@${identity.version}/${identity.relativePath}`);

    // here we can filter which modules to patch or not

    if (typeof module === 'function') {
        const tmpModule = { '': module };
        patchObject(tmpModule, identity);
        returnValue = tmpModule[''];
    }
    else {
        patchObject(returnValue, identity);
    }

    return returnValue;
};

