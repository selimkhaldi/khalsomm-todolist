/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Logger = require('../logger');
const Reader = require('./reader');
const Exception = require('../exception');
const Hoek = require('hoek');
const Callbacks = require('./rules-callback');
const Director = require('../instrumentation/director');
const CallbackBuilder = require('./rules-callback/callbackBuilder');
const Metric = require('../metric');

const getCallbacks = module.exports._getCallbacks = function (rule) {

    const hookpoint = rule.hookpoint;
    if (hookpoint.callback_class) {
        Hoek.assert(!!Callbacks[hookpoint.callback_class], `callback ${hookpoint.callback_class} is unknown`);
        return Callbacks[hookpoint.callback_class](rule);
    }
    else if (rule.callbacks) {
        return CallbackBuilder.getCbs(rule);
    }

    throw new Error(`no 'callbacks' nor 'hookpoint.callback_class' in rule ${rule}`);
};

const getHookPoint = module.exports._getHookPoint = function (hookPoint) {

    Hoek.assert(!!hookPoint.klass, 'key \'hookpoint.klass\' does not exist in rule');

    const target = hookPoint.klass; // moduleName#version:file
    let file = '';
    let versions = '';

    const hasVersion = target.indexOf('#') > -1;
    const hasFile = target.indexOf(':') > -1;

    const segments = target.split(/[#:]/g);
    if (hasFile) {
        file = segments.pop();
    }
    if (hasVersion) {
        versions = segments.pop();
    }
    const moduleName = segments.pop();

    Hoek.assert(!!moduleName, `could not find module name in ${target}`);

    const method = hookPoint.method || '';

    return {
        target: target + '::' + method,
        moduleName,
        methodName: method,
        file,
        versions
    };
};

const loadRuleList  = module.exports._loadRuleList = function (ruleList, doNotVerifySignature) {

    const result = [];

    for (let i = 0; i < ruleList.length; ++i) {

        const rule = ruleList[i];

        try {
            Reader.verifyRule(rule, doNotVerifySignature);
        }
        catch (err) {
            // if a rule does not have a valid signature, the whole rulespack is refused.
            Logger.DEBUG(`Rule ${rule.title} invalid: ${err} in pack ${rule.rulesPack}`);
            Exception.report(err).catch(() => {});
            return [];
        }

        try {
            Hoek.assert(!!rule.hookpoint, 'key \'hookpoint\' does not exist in rule');
            const hookpoint = getHookPoint(rule.hookpoint);
            hookpoint.callbacks = getCallbacks(rule);
            hookpoint.rule = rule;
            result.push(hookpoint);
        }
        catch (err) { // there is something wrong with this rule, let the backend know about it
            Logger.DEBUG(`Rule ${rule.title} invalid: ${err}`);
            Exception.report(err).catch(() => {});
        }
    }

    return result;
};

const collectHookPointsInstructions = module.exports._collectHookPointsInstructions = function (hookPointList) {

    const result = {};

    for (let i = 0; i < hookPointList.length; ++i) {

        const point = hookPointList[i];
        if (!result[point.target]) {
            result[point.target] = {
                moduleName: point.moduleName,
                methodName: point.methodName,
                file: point.file,
                versions: point.versions,
                params: {
                    preCbs: [],
                    postCbs: [],
                    failCbs: []
                }
            };
        }
        const goal = result[point.target];

        if (point.callbacks.pre) {
            goal.params.preCbs.push({ method: point.callbacks.pre, rule: point.rule });
        }

        if (point.callbacks.post) {
            goal.params.postCbs.unshift({ method: point.callbacks.post, rule: point.rule });
        }
        if (point.callbacks.fail) {
            goal.params.failCbs.unshift({ method: point.callbacks.fail, rule: point.rule });
        }
    }

    return result;
};

module.exports.enforceRuleList = function (ruleList, doNotVerifySignature) {

    const enforcable = collectHookPointsInstructions(loadRuleList(ruleList, doNotVerifySignature));

    const keys = Object.keys(enforcable);
    if (keys.length === 0) {
        return false;
    }

    // do metric related operations:
    ruleList.map((r) => r.metrics).reduce((a, b) => a.concat(b), []).forEach(Metric.getMetric);


    for (let i = 0; i < keys.length; ++i) {
        try {
            Director.update(enforcable[keys[i]]);
        }
        catch (err) {
            Logger.DEBUG(err);
        }
    }
    return true;
};
