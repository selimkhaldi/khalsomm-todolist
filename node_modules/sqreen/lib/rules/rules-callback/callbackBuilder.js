/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Runner = require('./../runner');
const Hoek = require('hoek');
const Exception = require('../../exception/index');
const Logger = require('../../logger');
const AsJson = require('@vdeturckheim/asjson');
const Util = require('./utils'); // TODO: explain this to CTO
const MainUtils = require('../../util');

const bindThis = module.exports._bindThis = function (key, cb, args, value, rule, selfObj, session) {

    session = session || {};

    if (key.indexOf('#') === 0) {
        // we need to bind with sqreen variables
        if (key === '#.caller') {
            return (new Error()).stack.split('Error\n').pop();
        }

        // TODO: use https://github.com/hapijs/hoek/blob/master/API.md#reachobj-chain-options
        const sqreenMatches = {
            '#.data': rule ? rule.data : {},
            '#.rv': value,
            '#.args': args,
            '#.inst': selfObj,
            '#.sess': session,
            '#.params': session,
            '#.client_ip': MainUtils.getXFFOrRemoteAddress(session)
        };
        const sqreenKeyList = Object.keys(sqreenMatches);

        for (let i = 0; i < sqreenKeyList.length; ++i) {
            const sqreenKey = sqreenKeyList[i];
            if (key.indexOf(sqreenKey) === 0) {
                const splitted = key.split(sqreenKey);

                const end = splitted.pop();
                const match = (end.match(/\['([\w|-]+)']|\[(\d+)]/g) || []).map((item) => item.replace('[\'', '').replace('\']', '').replace('[', '').replace(']', ''));
                if (!end || !match) {
                    return sqreenMatches[sqreenKey];
                }

                let tmp = sqreenMatches[sqreenKey];
                for (let j = 0; j < match.length; ++j) {
                    if (tmp[match[j]]) {
                        tmp = tmp[match[j]];
                    }
                }
                return tmp;
            }
        }
        // unknown key
        return null;
    }
    // integer
    const asInt = parseInt(key);
    if (isFinite(asInt)) {
        return asInt;
    }
    // string
    const match = key.match(/'(.*)'/);
    if (match) {
        return match[1];
    }
    // somkething else ?
    return null; // useless but expressive
};

const bindAccessors = module.exports._bindAccessors = function (cb, args, value, rule, selfObj, session) {

    const argumentsToPass = cb.slice(0, -1);

    for (let i = 0; i < argumentsToPass.length; ++i) {
        const key = argumentsToPass[i];
        argumentsToPass[i] = bindThis(key, cb, args, value, rule, selfObj, session);
    }

    return argumentsToPass;
};

const build = module.exports._build = function (cb, methods) {

    const fct = cb.slice(-1).pop();

    const context = Runner.getExecContext(fct);
    return function (args, value, rule, selfObj, session) {

        session = session || {};
        if (!session._clean) {
            session = AsJson(Util.getLookableClaims(session.req));
            session._clean = true;
        }

        args = args || [];
        const alternateArgs = Array.from(args);
        if (alternateArgs.length !== 0) { // collect potential garbage
            args = alternateArgs;
        }

        const params = bindAccessors(cb, args, value, rule, selfObj, session);

        const result = Runner.exec(context, params); // yes, those methods can change the values of the arguments passed to the instrumented methods

        if (result && result.call) { // result must not be a function, the first who returns a fct from a cb will have to offer me cookies everyday for the end of my life
            Hoek.assert(!!methods[result.call], `method ${result.call} is unknown in the context of rule: ${rule.title}`);

            const newArgs = result.args || args;
            value = result.data || value;// as in in https://github.com/sqreen/AgentRuby/blob/master/lib/sqreen/rules_callbacks/execjs.rb#L99
            // you can change the rule object here, it is cloned at each round
            return methods[result.call](newArgs, value, rule, selfObj, session);
        }

        if (rule && !rule.block && result && typeof result === 'object') {
            result.status = null;
        }

        return result;
    };
};

module.exports.getCbs = function (rule) {

    Hoek.assert(!!rule.callbacks, `no callbacks in rule ${rule}`);

    const callbacks = rule.callbacks.nodejs || rule.callbacks;
    const methodNames = Object.keys(callbacks);
    const methods = {};
    for (let i = 0; i < methodNames.length; ++i) {
        const name = methodNames[i];
        try {
            methods[name] = build(callbacks[name], methods, rule);
        }
        catch (err) {
            Logger.DEBUG(`could not compile callback ${name} in ${rule.title}`);
            Exception.report(new Error(`could not compile callback ${name} in ${rule.title}: ${err.message}`)).catch(() => {});
            return null; // we cannot do anything with this rule anymore !
        }
    }

    const result = {};

    result.pre = methods.pre;
    result.post = methods.post;
    result.fail = methods.fail;

    return result;
};
