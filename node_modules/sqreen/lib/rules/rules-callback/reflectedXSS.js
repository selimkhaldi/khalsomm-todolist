/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Util = require('./utils');
const Flat = require('flat');
const Escape = require('escape-html');

const GetRegexpMatcherObject = require('./regexpRule').getRegexpMatcherObject;

// goes to sqreen[""][""].__sqreen_escape

const XSSCB = class {

    constructor(rule) {

        this.patternList = rule && rule.data && rule.data.values || [];
        this.block = !!rule && rule.block;
        const self = this;

        this.matchers = this.patternList.map((p) => GetRegexpMatcherObject(p));

        this.pre = function (args, value, _rule, selfObj, session) {

            const str = args[0];
            const lookup = Flat(Util.getLookableClaims(session.req));

            return self.action(str, lookup, args);
        };
    }

    action(insertedStr, lookup, args) {

        const result = {};
        const keyList = Object.keys(lookup);
        for (let i = 0; i < keyList.length; ++i) {
            const key = keyList[i];
            if (lookup[key] === insertedStr) {
                if (this.block) {
                    args[0] = Escape(insertedStr);
                }

                // The remaining code is only to find out if user entry was an attack,
                // and record it. Since we don't rely on it to respond to user, it would
                // be better to do it in background (ie, in setImmediate).
                for (let j = 0; j < this.matchers.length; ++j) {
                    if (this.matchers[j].match(insertedStr)) {
                        result.record = { found: this.matchers[j].pattern, payload: insertedStr };
                        break;
                    }
                }
            }
        }
        return result;
    }
};

module.exports.getCbs = (r) => new XSSCB(r);
